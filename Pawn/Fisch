local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Fisch script.[Free] " .. Fluent.Version,
    SubTitle = "                               by Zefyr Team",
    TabWidth = 130,
    Size = UDim2.fromOffset(700, 520),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.K
})


local Tabs = {
    Home = Window:AddTab({ Title = "Home", Icon = "tv" }),
    Pref = Window:AddTab({ Title = "Performance", Icon = "wrench" }),
    Fishing = Window:AddTab({ Title = "Fishing", Icon = "anchor" }),
    Auto = Window:AddTab({ Title = "Automatics", Icon = "repeat" }),
    Player = Window:AddTab({ Title = "Player", Icon = "person-standing" }),
    Teleports = Window:AddTab({ Title = "Teleports", Icon = "mountain" }),
    Misc = Window:AddTab({ Title = "Miscellaneous", Icon = "shuffle" }),
    Test = Window:AddTab({ Title = "Testing", Icon = "shield-check" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
    
}

-- Pre script stuff
-- Pre script stuff
-- Pre script stuff

-- Startup thing
Fluent:Notify({
        Title = "Zefyr Is Loading",
        Content = "This Wont Take Long",
        SubContent = "➡",
        Duration = 5
})










local player = game.Players.LocalPlayer
local statChangeList = player.PlayerGui.hud.safezone.StatChangeList

local originalText = statChangeList.Text

-- Start the loop
spawn(function()
    while true do
        statChangeList.Text = "GET ZEFYR NOW"
        wait(0.1)
        statChangeList.Text = "GET ZEFYR NOW"
        wait(0.1)
    end
end)




-- Anti afk
;local bb=game:service'VirtualUser'
game:service'Players'.LocalPlayer.Idled:connect(function()
bb:CaptureController()bb:ClickButton2(Vector2.new())
ab.Text="Roblox tried kicking you buy I didnt let them!"wait(2)ab.Text="Status : Active"end)











local Options = Fluent.Options

do

-- << Main tab >>
-- << Main tab >>
-- << Main tab >>


local DisplayName = game.Players.LocalPlayer.DisplayName
print("Display found")
print(DisplayName)


local PlayerName = game.Players.LocalPlayer.Name
print("User found")
print(PlayerName)


Tabs.Home:AddParagraph({
    Title = "Welcome " .. DisplayName .. "!",
    Content = "User: " .. PlayerName,
})

Tabs.Home:AddParagraph({
    Title = "Changelog",
    Content = "Added New Zone farm \nAdded Better freeze \nAdded faster shake."
})


    



-- << Preformace Tab >>
-- << Preformace Tab >>
-- << Preformace Tab >>

local Section = Tabs.Pref:AddSection("Main")


local player = game.Players.LocalPlayer
local radius = 50  -- Adjust the radius to the desired distance

local IsRemoving = false
    
Tabs.Pref:AddButton({
    Title = "Destroy all Particle Emitters",
    Description = "IRREVERSABLE",
    Callback = function()
        local position = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
        if position then

                    IsRemoving = true
                    while IsRemoving do
            
            for _, part in ipairs(workspace:FindPartsInRegion3(workspace.CurrentCamera.CFrame:pointToWorldSpace(position) - Vector3.new(radius, radius, radius), Vector3.new(radius*2, radius*2, radius*2), nil)) do
                -- Check if the part has a ParticleEmitter
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("ParticleEmitter") then
                        child:Destroy()
                                end
                    end
                end
            end
        else
            
        end
    end
})

    

local isdisabling = false
local VFX = game.Lighting

local Toggle = Tabs.Pref:AddToggle("VFXToggle", 
{
    Title = "Less lag", 
    Description = "",
    Default = false,
    Callback = function(state)
	if state then
    isdisabling = true

    while isdisabling do

    VFX.bloom.Enabled = false
    VFX.sunrays.Enabled = false
    wait(1)
        end
                    
	    
	else

    isdisabling = false
    VFX.bloom.Enabled = true
    VFX.sunrays.Enabled = true              
	    
        end
    end 
})   



    


-- << Fishing Tab >>
-- << Fishing Tab >>
-- << Fishing Tab >>


local IsCasting = false

local ToggleCast = Tabs.Fishing:AddToggle("CastToggle", 
{
    Title = "Auto Cast", 
    Description = "",
    Default = false,
    Callback = function(state)
        if state then
            IsCasting = true
            
            task.spawn(function()
                while IsCasting do
                    local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
                    local rod = nil
                    
                    for _, child in ipairs(character:GetDescendants()) do
                        if child:IsA("Tool") and string.find(child.Name, "Rod") then
                            rod = child
                            break
                        end
                    end

                    if rod then
                        local rodEvents = rod:FindFirstChild("events")
                        if rodEvents then
                            local castEvent = rodEvents:FindFirstChild("cast")
                            if castEvent and castEvent:IsA("RemoteEvent") then
                                local args = {
                                    [1] = 11.5,
                                    [2] = 1
                                }
                                castEvent:FireServer(unpack(args))
                            end
                        end
                    end

                    task.wait(1)
                end
            end)
        else
            IsCasting = false
        end
    end  
})








local player = game.Players.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")
local IsShaking = false

local Toggle = Tabs.Fishing:AddToggle("ShakeToggle", 
{
    Title = "Auto Shake", 
    Description = "",
    Default = true,
    Callback = function(state)
        if state then
            IsShaking = true

            task.spawn(function()
                while IsShaking do
                    -- Attempt to find the button hierarchy
                    local button
                    while not button and IsShaking do
                        button = player.PlayerGui:FindFirstChild("shakeui")
                            and player.PlayerGui.shakeui:FindFirstChild("safezone")
                            and player.PlayerGui.shakeui.safezone:FindFirstChild("button")

                        if not button then
                            
                            task.wait(0) -- Retry after a short delay
                        end
                    end

                    if button then
                        -- Get button position and size
                        local buttonPosition = button.AbsolutePosition
                        local buttonSize = button.AbsoluteSize
                        local clickPosition = buttonPosition + (buttonSize / 2)  

                        -- Simulate a button click
                        VirtualInputManager:SendMouseButtonEvent(clickPosition.X, clickPosition.Y, 0, true, game, 0)
                        task.wait(0)
                        VirtualInputManager:SendMouseButtonEvent(clickPosition.X, clickPosition.Y, 0, false, game, 0)

                        task.wait(0) -- Delay between shakes
                    end
                end
            end)
        else
            IsShaking = false
        end
    end 
})








local IsReeling = false

local ToggleReel = Tabs.Fishing:AddToggle("ReelToggle", 
{
    Title = "Auto Reel", 
    Description = "",
    Default = true,
    Callback = function(state)
        if state then
            IsReeling = true
            
            task.spawn(function()
                while IsReeling do
                    local args = {
                        [1] = 100,
                        [2] = true
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("events"):WaitForChild("reelfinished"):FireServer(unpack(args))

                    task.wait(0.1)
                end
            end)
        else
            IsReeling = false
        end
    end
})






    


local Toggle = Tabs.Fishing:AddToggle("MyToggle", 
{
    Title = "Auto Bobber Drop", 
    Description = "",
    Default = false,
    Callback = function(state)
	if state then

game.Workspace.Gravity = 1000
               
	else
game.Workspace.Gravity = 196.1999969482422	    
                    
        end
    end 
})





    

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local rodNameValue = character:FindFirstChild("RodNameValue")
if not rodNameValue then
    rodNameValue = Instance.new("StringValue")
    rodNameValue.Name = "RodNameValue"
    rodNameValue.Parent = character
end

local isActive = false

local function updateRodName()
    local foundRod = nil

    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool:IsA("Tool") and string.find(tool.Name, "Rod") then
            foundRod = tool.Name
            break
        end
    end

    if not foundRod then
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and string.find(tool.Name, "Rod") then
                foundRod = tool.Name
                break
            end
        end
    end

    rodNameValue.Value = foundRod or ""
end

player.Backpack.ChildAdded:Connect(updateRodName)
player.Backpack.ChildRemoved:Connect(updateRodName)
character.ChildAdded:Connect(updateRodName)
character.ChildRemoved:Connect(updateRodName)

local function findRod()
    local rodName = rodNameValue.Value
    if rodName and rodName ~= "" then
        return character:FindFirstChild(rodName)
    end
    return nil
end

local function findBobber(rod)
    return rod and rod:FindFirstChild("bobber")
end

local function findBite(rod)
    if rod then
        local values = rod:FindFirstChild("values")
        if values then
            return values:FindFirstChild("bite")
        end
    end
    return nil
end

local Toggle = Tabs.Fishing:AddToggle("BobberToggle", 
{
    Title = "Auto Teleport Bobber", 
    Description = "Teleports the bobber over the player",
    Default = false,
    Callback = function(state)
        isActive = state

        if state then
            task.spawn(function()
                while isActive do
                    updateRodName()

                    local rod = findRod()
                    if not rod then
                        task.wait(1)
                        continue
                    end

                    local bobber = findBobber(rod)
                    if not bobber then
                        task.wait(1)
                        continue
                    end

                    local bite = findBite(rod)
                    if not bite then
                        task.wait(1)
                        continue
                    end

                    if bite.Value == true or bite.Value == 1 then
                        local playerHRP = character:FindFirstChild("HumanoidRootPart")
                        if playerHRP then
                            
                            wait(0.2)
                            local targetPosition = playerHRP.Position + Vector3.new(0, -1, 0)
                            bobber.Position = targetPosition
                        end

                        while bite.Value == true or bite.Value == 1 do
                            task.wait(0.5)
                        end
                    end

                    task.wait(0.5)
                end
            end)
        else
            isActive = false
        end
    end
})
    

local Section = Tabs.Fishing:AddSection("Zone Fishing")

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local teleportLocations = {
    ["Ancient Isles Pond"] = Vector3.new(6030.05517578125, 176.0491485595703, 375.9239196777344),
    ["Cryogenic Canal"] = Vector3.new(20036, 509, 5461),
    ["Forsaken Shores Pond"] = Vector3.new(-2666, 149, 1768),
    ["The Depths"] = Vector3.new(529, -744, 1229),
}

-- Variable to store the chosen teleport location (as island name)
local ChosenZone = nil

-- Variable to track whether the player is frozen
local isFrozen = false

-- Dropdown for selecting the teleport location
local Dropdown = Tabs.Fishing:AddDropdown("IslandDropdown", {
    Title = "Teleport To Island",
    Values = {"Ancient Isles Pond", "Cryogenic Canal", "Forsaken Shores Pond", "The Depths"},
    Multi = false,
    Default = nil,
    Callback = function(selected)
        ChosenZone = selected -- Store the selected island name
        print("Chosen teleport location:", selected)
    end
})

Dropdown:SetValue(nil)

-- Function to disable player movement by setting WalkSpeed and JumpPower to 0
function disablePlayerMovement1()
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
    end
end

-- Function to enable player movement by restoring default WalkSpeed and JumpPower
function enablePlayerMovement1()
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16 -- Default walk speed
        humanoid.JumpPower = 50 -- Default jump power
    end
end

-- Function to enforce freezing by keeping the character on the platform using Heartbeat
function enforceFreeze()
    local RunService = game:GetService("RunService")
    local connection

    connection = RunService.Heartbeat:Connect(function()
        if not isFrozen then
            connection:Disconnect() -- Stop the connection when no longer frozen
            return
        end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local platform = workspace:FindFirstChild("SigmaPart")
        if humanoidRootPart and platform then
            humanoidRootPart.CFrame = platform.CFrame + Vector3.new(0, 3, 0)
        end
    end)
end

-- Function to spawn a platform under the player
function spawnPlatform()
    local platform = Instance.new("Part")
    platform.Name = "SigmaPart"
    platform.Size = Vector3.new(6, 1, 6)
    platform.Anchored = true
    platform.Transparency = 0.5
    platform.BrickColor = BrickColor.new("Bright blue")
    platform.CanCollide = true
    platform.Parent = workspace

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        platform.Position = humanoidRootPart.Position - Vector3.new(0, humanoidRootPart.Size.Y / 2 + 1, 0)
    end
end

-- Function to remove the platform under the player
function removePlatform()
    local platform = workspace:FindFirstChild("SigmaPart")
    if platform then
        platform:Destroy()
    end
end

-- Table to store initial CanCollide states of parts
local initialCanCollideStates = {}

-- Function to store CanCollide states of all parts in the workspace
function storeCanCollideStates()
    for _, obj in ipairs(workspace:GetDescendants()) do
        -- Only store CanCollide state for parts that are not in the player model, are not water, and are not SigmaPart
        if (obj:IsA("Part") or obj:IsA("MeshPart")) and
            not obj:IsDescendantOf(character) and
            obj.Name ~= "Water" and
            obj.Name ~= "SigmaPart" then
            initialCanCollideStates[obj] = obj.CanCollide
        end
    end
end

-- Function to make all parts uncollidable, while remembering their original state
function makePartsUncollidable()
    storeCanCollideStates()
    for _, obj in ipairs(workspace:GetDescendants()) do
        -- Check if the object is a Part or MeshPart, is not part of the player's model, is not water, and is not SigmaPart
        if (obj:IsA("Part") or obj:IsA("MeshPart")) and 
            not obj:IsDescendantOf(character) and
            obj.Name ~= "Water" and
            obj.Name ~= "SigmaPart" then
            -- Only disable collision if it was originally collidable
            if initialCanCollideStates[obj] ~= false then
                obj.CanCollide = false
            end
        end
    end
end

-- Function to restore collision to all parts based on their original state
function restoreCollision()
    for obj, originalState in pairs(initialCanCollideStates) do
        if obj and obj.Parent then -- Check if the object still exists
            obj.CanCollide = originalState
        end
    end
end

-- Freeze toggle functionality
local FreezeToggle = Tabs.Fishing:AddToggle("FreezeToggle", {
    Title = "Freeze in zone",
    Description = "Freeze the character at the chosen location",
    Default = false,
    Callback = function(state)
        isFrozen = state

        if isFrozen then
            -- Only teleport if ChosenZone has been selected
            if ChosenZone then
                local teleportPosition = teleportLocations[ChosenZone]
                if teleportPosition then
                    -- Set the character's position to the teleport location and freeze
                    character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))

                    spawnPlatform()
                    disablePlayerMovement1()
                    spawn(enforceFreeze)
                    makePartsUncollidable() -- Make all parts uncollidable
                end
            else
                print("No teleport location selected!")
                -- Optionally, you could notify the user that they need to select a teleport location
            end
        else
            enablePlayerMovement1()
            removePlatform()
            restoreCollision() -- Restore collision to all parts
        end
    end
})













    

local Dropdown = Tabs.Fishing:AddDropdown("Dropdown", {
    Title = "Choose Event",
    Description = "Dropdown description",
    Values = {"Didnt work on this"},
    Multi = false,
    Default = 1,
})

local Toggle = Tabs.Fishing:AddToggle("MyToggle", 
{
    Title = "Another feature idk", 
    Description = "Didnt work on this",
    Default = false,
    Callback = function(state)
	if state then
	    
	else
	    
        end
    end 
})

    

local Section = Tabs.Fishing:AddSection("Misc")







-- << Automatics tab >>
-- << Automatics tab >>
-- << Automatics tab >>

    


local Section = Tabs.Auto:AddSection("Atlantis")




local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

Tabs.Auto:AddButton({
    Title = "Pull all levers",
    Description = "",
    Callback = function()
        -- Define the locations to teleport to
        local locations = {
            Vector3.new(-2835.617919921875, 130.71356201171875, 1508.743408203125),
            Vector3.new(-2729.596435546875, 167.3095703125, 1731.5970458984375),
            Vector3.new(-2881.69482421875, 314.7715148925781, 1606.7078857421875),
            Vector3.new(-2522.49072265625, 138.621826171875, 1592.4261474609375),
            Vector3.new(-2552.0234375, 152.73927307128906, 1665.2774658203125)
        }

        humanoidRootPart.CFrame = CFrame.new(-2590, 145, 1589)  

        wait(1)

        -- Function to simulate pressing "E"
        local function simulateKeyPress()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            wait(0.1)  -- Small delay to simulate holding the key
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        end

        -- Function to teleport and press "E"
        local function teleportAndPressE()
            for _, location in ipairs(locations) do
                -- Teleport the player to the location
                humanoidRootPart.CFrame = CFrame.new(location)
                wait(0.2) -- Wait to ensure the teleport is completed

                -- Simulate pressing "E"
                simulateKeyPress()
                wait(0.2) -- Wait to ensure interaction is completed
            end
        end

        -- Run the function
        teleportAndPressE()
    end
})






























-- << Player Tab >>
-- << Player Tab >>
-- << Player Tab >>

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local platform -- Variable for the platform part
local frozenPosition -- Variable to store the position where the player was frozen
local toggleActive = false -- Track toggle state

-- Create a platform under the player
local function createPlatform()
    platform = Instance.new("Part")
    platform.Size = Vector3.new(10, 1, 10) -- Size of the platform
    platform.Anchored = true
    platform.CanCollide = true -- Ensure the platform can collide with the player
    platform.Transparency = 0.5 -- Adjust transparency
    platform.Parent = workspace
end

-- Remove the platform
local function removePlatform()
    if platform then
        platform:Destroy()
        platform = nil
    end
end

-- Disable player's movement
local function disablePlayerMovement()
    humanoid.WalkSpeed = 1
    humanoid.JumpPower = 1
end

-- Enable player's movement
local function enablePlayerMovement()
    humanoid.WalkSpeed = 16 -- Default walk speed
    humanoid.JumpPower = 50 -- Default jump power
end

-- Update the platform's position and enforce freeze
local function enforceFreeze()
    while toggleActive do
        if frozenPosition then
            -- Update platform position under the frozen position
            if platform then
                platform.Position = frozenPosition - Vector3.new(0, 3, 0) -- 3 studs below
            end

            -- Teleport player to frozen position
            humanoidRootPart.CFrame = CFrame.new(frozenPosition)

            -- Maintain zero movement capability
            humanoid.WalkSpeed = 1
            humanoid.JumpPower = 1
        end
        wait(0.1) -- Update every 0.1 seconds
    end
end

-- Toggle logic
local Toggle = Tabs.Player:AddToggle("PlatformToggle", {Title = "Freeze Character", Default = false})
Toggle:OnChanged(function(state)
    toggleActive = state

    if state then
        -- Store the player's current position
        frozenPosition = humanoidRootPart.Position

        -- Create the platform under the player
        if not platform then
            createPlatform()
        end
        platform.Position = frozenPosition - Vector3.new(0, 3, 0) -- Place platform below the player

        -- Disable player movement and start enforcing freeze
        disablePlayerMovement()
        spawn(enforceFreeze)
    else
        -- Re-enable player movement and remove platform
        enablePlayerMovement()
        removePlatform()
    end
end)















    local Slider = Tabs.Player:AddSlider("Slider", {
        Title = "WalkSpeed",
        Description = "This Makes You Go Wroom",
        Default = 16,
        Min = 16,
        Max = 1000,
        Rounding = 1,
        Callback = function(Value)

            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
            
        end
    })



 Tabs.Player:AddButton({
        Title = "Infinite jump",
        Description = "Lets you jump infintely what else",
        Callback = function()
            Window:Dialog({
                Title = "Alert",
                Content = "This prolly doesnt have a turn off function",
                Buttons = {
                    {
                        Title = "Oki😔",
                        Callback = function()
                            
                        end
                    },
                    {
                        Title = "Negro stfu",
                        Callback = function()
                            
                        end
                    }
                }
            })

    --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	--Notifies readiness
	game.StarterGui:SetCore("SendNotification", {Title="WeAreDevs.net"; Text="The WeAreDevs Infinite Jump exploit is ready!"; Duration=5;})

	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
                
        end
    })













local Toggle = Tabs.Player:AddToggle("WalkWater", { Title = "Walk On Water", Default = false })

local part = nil
local following = false

local function createPart()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    part = Instance.new("Part")
    part.Size = Vector3.new(6, 1, 6)
    part.Position = Vector3.new(humanoidRootPart.Position.X, 126.5, humanoidRootPart.Position.Z)
    part.Anchored = true
    part.CanCollide = true
    part.Transparency = 0.8
    part.Parent = workspace
end

local function updatePartPosition()
    if part then
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        
        part.Position = Vector3.new(humanoidRootPart.Position.X, 126.5, humanoidRootPart.Position.Z)
    end
end

Toggle:OnChanged(function(state)
    if state then
        if not part then
            createPart()
        end
        following = true
        
        game:GetService("RunService").Heartbeat:Connect(function()
            if following then
                updatePartPosition()
            end
        end)
    else
        following = false
        if part then
            part:Destroy()
            part = nil
        end
    end
end)

Options.WalkWater:SetValue(false)



    















-- Game tab
-- Game tab
-- Game tab





 





-- Teleports tab
-- Teleports tab
-- Teleports tab



-- Create a new part
local newPart = Instance.new("Part")

-- Set its properties
newPart.Size = Vector3.new(50, 3, 50)
newPart.Position = Vector3.new(-3646, -227, 663)
newPart.Anchored = true
newPart.Name = "SafePart"


newPart.Parent = game.Workspace


Tabs.Teleports:AddButton({
    Title = "Teleport To Safe",
    Description = "Just a platform with water",
    Callback = function()
        
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        
        local teleportLocation = CFrame.new(-3646, -228, 663)

        
        character:SetPrimaryPartCFrame(teleportLocation)
    end
})



local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local teleportLocations = {
    ["Moosewood"] = Vector3.new(480, 150, 261),
    ["Ancient Isles"] = Vector3.new(6058, 195, 279),
    ["Roslit Bay"] = Vector3.new(-1469, 132, 703),
    ["Sunstone Island"] = Vector3.new(-929, 131, -1112),
    ["Snowcap Island"] = Vector3.new(2610, 135, 2432),
    ["Forsaken Shores"] = Vector3.new(-2515, 137, 1560),
    ["Mushgrove Swamp"] = Vector3.new(2522, 131, -708),
    ["Statue Of Sovereignty"] = Vector3.new(22, 148, -1016),
    ["Terrapin Island"] = Vector3.new(-167, 142, 1925),
    ["Grand Reef"] = Vector3.new(-3596, 150, 537),
    ["Northen Expedition"] = Vector3.new(19623, 131, 5236),
    ["Northen Expedition Top"] = Vector3.new(20007, 1136, 5533),
    ["Overgrowth Caves"] = Vector3.new(19789, 418, 5637),
    ["Vertigo"] = Vector3.new(-112, -515, 1143),
    ["The Depths"] = Vector3.new(557, -704, 1223),
    ["Cryogenic Canal"] = Vector3.new(20058, 561, 5465),
    ["Glacial Grotto"] = Vector3.new(19977, 930, 5644),
    ["Desolate Deep"] = Vector3.new(-1658, -214, -2845),
    ["Brine Pool"] = Vector3.new(-1794, -142, -3400),
    ["Keepers Altar"] = Vector3.new(1310, -802, -83),
}

-- Assuming you have a UI library or tab system set up
local Dropdown = Tabs.Teleports:AddDropdown("IslandDropdown", {
        Title = "Teleport To Island",
    Values = {"Ancient Isles", "Brine Pool", "Cryogenic Canal", "Desolate deep", "Forsaken Shores", "Grand Reef", "Glacial Grotto", "Mushgrove Swamp", "Keepers Altar", "Moosewood", "Northen Expedition", "Northen Expedition Top", "Overgrowth Caves", "Roslit Bay", "Statue Of Sovereignty", "Snowcap Island", "Sunstone Island", "Terrapin Island", "The Depths",  "Vertigo"},
    Multi = false,
    Default = nil,
})

Dropdown:SetValue(nil)

Dropdown:OnChanged(function(Value)
    -- Check if the selected value matches a key in teleportLocations
    if teleportLocations[Value] then
        -- Teleport the player to the selected location
        character:SetPrimaryPartCFrame(CFrame.new(teleportLocations[Value]))
    else
        
    end
end)

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local Dropdown
local function updatePlayerDropdown()
    local players = {"None"} -- Add "None" as the first option
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player then -- Exclude the local player
            table.insert(players, p.Name)
        end
    end

    if Dropdown then
        Dropdown.Values = players
        Dropdown:SetValue("None") -- Default to "None"
    end
end

Dropdown = Tabs.Teleports:AddDropdown("TeleportToPlayerDropdown", {
    Title = "Teleport to Player ( Bugged )",
    Values = {}, -- Start empty
    Multi = false,
})

Dropdown:OnChanged(function(playerName)
    if playerName == "None" then
        
        -- Optionally teleport to current position
        -- character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame)
    elseif playerName and playerName ~= "" then
        local targetPlayer = game.Players:FindFirstChild(playerName)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            character:SetPrimaryPartCFrame(targetPlayer.Character.HumanoidRootPart.CFrame)
        else
            
        end
    else
        
    end
end)

game.Players.PlayerAdded:Connect(updatePlayerDropdown)
game.Players.PlayerRemoving:Connect(updatePlayerDropdown)

updatePlayerDropdown()



-- Define teleport locations (Initially nil because the zones may not spawn immediately)
local teleportLocations = {
    ["Megalodon"] = nil,
    ["Mushgrove Algae Pool"] = nil,
    ["Snowcap Algae Pool"] = nil,
    ["Forsaken Algae Pool"] = nil,
    ["Ancient Algae Pool"] = nil,
    ["Golden Tide"] = nil,
    ["Great Hammerhead Shark"] = nil,
    ["Whale Shark"] = nil,
}

-- Create a dropdown with predefined zones (with "Pool" added to algae names)
local Dropdown = Tabs.Teleports:AddDropdown("EventZoneDropdown", {
    Title = "Teleport to zone/Event",
    Values = {"Megalodon", "Mushgrove Algae Pool", "Snowcap Algae Pool", "Forsaken Algae Pool", "Ancient Algae Pool", "Golden Tide", "Great Hammerhead Shark", "Whale Shark"},
    Multi = false,
})

-- When a dropdown selection is made
Dropdown:OnChanged(function(selectedZone)
    -- Ensure selectedZone is valid before using it
    if not selectedZone or selectedZone == "" then
        
        return
    end
    
    -- Find zones folder and fishing zone
    local zones = game.Workspace:FindFirstChild("zones")
    if not zones then
        warn("Zones folder not found!")
        return
    end

    local fishingZone = zones:FindFirstChild("fishing")
    if not fishingZone then
        warn("Fishing zone not found!")
        return
    end

    -- Only search for the selected zone
    local targetPart = fishingZone:FindFirstChild(selectedZone)
    
    if targetPart then
        -- If the part is found, teleport to it slightly above the target location (e.g., 5 studs higher)
        teleportLocations[selectedZone] = targetPart.Position
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local rootPart = character:WaitForChild("HumanoidRootPart")
        
        -- Teleport to a position above the target location (5 studs above)
        local teleportPosition = targetPart.Position + Vector3.new(0, 75, 0)
        
        rootPart.CFrame = CFrame.new(teleportPosition)
        print("Teleported to", selectedZone, "at position:", teleportPosition)
    else
        -- Notify if the part wasn't found (although it should be found if it was listed)
        Fluent:Notify({
            Title = "Notification",
            Content = selectedZone .. " not found!",
            SubContent = "🎣", -- Optional icon
            Duration = 9
        })
    end
end)



local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local teleportLocations = {
    ["Appraiser"] = Vector3.new(453.182373046875, 150.50003051757812, 206.90878295898438),

}

-- Assuming you have a UI library or tab system set up
local Dropdown = Tabs.Teleports:AddDropdown("IslandDropdown", {
    Title = "Teleport Interractable",
    Values = {"Appraiser"},
    Multi = false,
    Default = nil,
})

Dropdown:SetValue(nil)

Dropdown:OnChanged(function(Value)
    -- Check if the selected value matches a key in teleportLocations
    if teleportLocations[Value] then
        -- Teleport the player to the selected location
        character:SetPrimaryPartCFrame(CFrame.new(teleportLocations[Value]))
    else
        
    end
end)





-- Misc tab
-- Misc tab
-- Misc tab



Tabs.Misc:AddButton({
    Title = "Rainbow rod (Irreversable)",
    Callback = function()
        -- Variables
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local CurrentRod = nil -- Holds the reference to the currently equipped rod

        -- Function to update CurrentRod dynamically
        local function updateCurrentRod()
            local function findRod(container)
                for _, child in ipairs(container:GetChildren()) do
                    if child:IsA("Tool") and string.find(child.Name, "Rod") then
                        return child
                    end
                end
                return nil
            end

            -- Search in Backpack and Character
            CurrentRod = findRod(player.Backpack) or findRod(character)

            if CurrentRod then
                print("CurrentRod set to:", CurrentRod.Name)
            else
                warn("No rod found!")
            end
        end

        -- Function to apply the rainbow effect
        local function applyRainbowEffect()
            if not CurrentRod then
                warn("CurrentRod not found!")
                return
            end

            local detailsModel = CurrentRod:FindFirstChild("Details")
            if not detailsModel then
                warn("Details model not found in CurrentRod!")
                return
            end

            local allParts = detailsModel:GetDescendants()

            -- Apply rainbow effect
            game:GetService("RunService").RenderStepped:Connect(function()
                for _, part in ipairs(allParts) do
                    if part:IsA("BasePart") then -- Includes MeshParts, Parts, and similar
                        local hue = tick() % 5 / 5 -- Cycle through colors
                        part.Color = Color3.fromHSV(hue, 1, 1)
                    end
                end
            end)
        end

        -- Initial update and apply effect
        updateCurrentRod()
        applyRainbowEffect()
    end
})







local Section = Tabs.Misc:AddSection("Game")

Tabs.Misc:AddButton({
    Title = "Kill Player",
    Description = "Literally Kills you",
    Callback = function()

local args = {
    [1] = 0
}

game:GetService("ReplicatedStorage"):WaitForChild("events"):WaitForChild("drown"):FireServer(unpack(args))
game:GetService("ReplicatedStorage"):WaitForChild("events"):WaitForChild("drown"):FireServer(unpack(args))

                
    end
})

    Tabs.Misc:AddButton({
    Title = "Discover All Locations",
    Description = "Gives Free XP. Might take time for now.",
    Callback = function()

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Save the starting location
local startPosition = humanoidRootPart.CFrame

local locations = {
    Vector3.new(480, 150, 261),
    Vector3.new(6058, 195, 279),
    Vector3.new(-1469, 132, 703),
    Vector3.new(-929, 131, -1112),
    Vector3.new(2610, 135, 2432),
    Vector3.new(-2515, 137, 1560),
    Vector3.new(2522, 131, -708),
    Vector3.new(22, 148, -1016),
    Vector3.new(-167, 142, 1925),
    Vector3.new(-3596, 150, 537),
    Vector3.new(19623, 131, 5236),
    Vector3.new(20007, 1136, 5533),
    Vector3.new(19789, 418, 5637),
    Vector3.new(-112, -515, 1143),
    Vector3.new(557, -704, 1223),
    Vector3.new(20058, 561, 5465),
    Vector3.new(19977, 930, 5644),
    Vector3.new(-1911, 171, 294),
    Vector3.new(-1658, -214, -2845),
    Vector3.new(-1794, -142, -3400),
}

-- Teleport to each location
for _, position in ipairs(locations) do
    humanoidRootPart.CFrame = CFrame.new(position)
    wait(2) -- Pause between teleports
end

-- Teleport back to the starting location
humanoidRootPart.CFrame = startPosition





 
    end
})


   local Toggle = Tabs.Misc:AddToggle("Oxygen Toggle", 
{
    Title = "Disable Oxygen", 
    Description = "",
    Default = true,
    Callback = function(state)
        if state then
            game.Workspace[PlayerName].oxygen.Disabled = true
        else
            game.Workspace[PlayerName].oxygen.Disabled = false
        end
    end 
})


local Toggle = Tabs.Misc:AddToggle("Oxygen peaks Toggle", 
{
    Title = "Disable Oxygen (Peaks)", 
    Description = "",
    Default = false,
    Callback = function(state)
        if state then
            game.Workspace[PlayerName]["oxygen(peaks)"].Disabled = true
        else
            game.Workspace[PlayerName]["oxygen(peaks)"].Disabled = false
        end
    end 
})


local Toggle = Tabs.Misc:AddToggle("Tempature Toggle", 
{
    Title = "Disable Temperature", 
    Description = "",
    Default = false,
    Callback = function(state)
        if state then
            game.Workspace[PlayerName].temperature.Disabled = true
        else
            game.Workspace[PlayerName].temperature.Disabled = false
        end
    end 
})




local shadowsFolder = game.Workspace.Shadows  

Tabs.Misc:AddButton({
    Title = "Destroy Ghosts",
    Description = "",
    Callback = function()


for _, child in ipairs(shadowsFolder:GetChildren()) do
    child:Destroy()
end

            

end
})

 

local Lighting = game:GetService("Lighting")
local brightnessEffect = Lighting:FindFirstChild("brightness")
local sunraysEffect = Lighting:FindFirstChild("sunrays")

local Toggle = Tabs.Misc:AddToggle("FlashToggle", 
{
    Title = "Anti Flash", 
    Description = "Turn this on if you feel like your screen is a bit too bright sometimes",
    Default = false,
    Callback = function(state)

        if brightnessEffect and brightnessEffect:IsA("ColorCorrectionEffect") then

            if sunraysEffect and sunraysEffect:IsA("SunRaysEffect") then
                if state then   
                    brightnessEffect.Brightness = -0.1
                    sunraysEffect.Enabled = false
                else
                    brightnessEffect.Brightness = 0.1
                    sunraysEffect.Enabled = true

game.Lighting.brightness.Enabled = true
brightnessEffect.Brightness = 0.1

                end
            else

            end
        else

        end
    end
})





local WaterColor = game.Lighting.underwatercc
local WaterBlur = game.Lighting.underwaterbl


local running = false

local Toggle = Tabs.Misc:AddToggle("WaterFogToggle", 
{
    Title = "Clear Water", 
    Description = "Lets you see better while swimming",
    Default = false,
    Callback = function(state)
	if state then

        running = true

    while running do
WaterBlur.Enabled = false
WaterColor.Enabled = false
        wait(0.1)
        end
         
                    
    else
                    
    running = false                
                    
        end
    end 
})













    

local Section = Tabs.Misc:AddSection("Identity")

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local overlayParts = {}  -- Table to track overlays

local function toggleOverlay(state)
    if state then
        -- Create overlays if toggled ON
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                -- Create an overlay part slightly larger than the original part
                local overlay = Instance.new("Part")
                overlay.Size = part.Size + Vector3.new(0.2, 0.2, 0.2)
                overlay.Position = part.Position
                overlay.Anchored = false
                overlay.CanCollide = false
                overlay.Transparency = 0  -- Make it semi-transparent for hiding effect
                overlay.Color = Color3.fromRGB(241, 212, 246)  -- Customize color as needed

                -- Create a weld to attach the overlay part to the character part
                local weld = Instance.new("Weld")
                weld.Part0 = part
                weld.Part1 = overlay
                weld.C0 = CFrame.new(0, 0, 0)
                weld.Parent = overlay

                overlay.Parent = character
                overlayParts[overlay] = true  -- Store overlay in table
            end
        end
    else
        -- Destroy overlays if toggled OFF
        for overlay, _ in pairs(overlayParts) do
            if overlay then
                overlay:Destroy()
            end
        end
        overlayParts = {}  -- Clear the table
    end
end

-- Create the toggle
local Toggle = Tabs.Misc:AddToggle("MyToggle", {
    Title = "Hide Avatar",
    Description = "Brickyy",
    Default = false
})

-- Respond to toggle state change
Toggle:OnChanged(function(state)
    toggleOverlay(state)
end)

-- Reset toggle programmatically if needed
Options.MyToggle:SetValue(false)

local player = game.Players.LocalPlayer
local userPart = player.Character:WaitForChild("HumanoidRootPart"):WaitForChild("user"):WaitForChild("user")

local originalDisplayName = player.DisplayName  -- Store the original display name

local Toggle = Tabs.Misc:AddToggle("NameToggle", {
    Title = "Hide Name",
    Default = false
})

Toggle:OnChanged(function(state)
    userPart.Text = state and ".gg/52QaAMTMeH" or originalDisplayName  -- Toggle between custom text and display name
end)

Options.NameToggle:SetValue(false)


local player = game.Players.LocalPlayer
local streakPart = player.Character:WaitForChild("HumanoidRootPart"):WaitForChild("user"):WaitForChild("streak")

local originalStreak = streakPart.Text

local Toggle = Tabs.Misc:AddToggle("StreakToggle", {
    Title = "Hide Streak",
    Default = false
})

streakPart:GetPropertyChangedSignal("Text"):Connect(function()
    if streakPart.Text ~= originalStreak then
        originalStreak = streakPart.Text
    end
end)

local isLooping = false

Toggle:OnChanged(function(state)
    isLooping = state
end)

spawn(function()
    while true do
        if isLooping then
            streakPart.Text = "∞"
        else
            streakPart.Text = originalStreak
        end
        wait(0.1)
    end
end)




local player = game.Players.LocalPlayer
local levelPart = player.Character:WaitForChild("HumanoidRootPart"):WaitForChild("user"):WaitForChild("level")

local originalLevel = levelPart.Text  -- Store the original level value

local Toggle = Tabs.Misc:AddToggle("LevelToggle", {
    Title = "Hide Level",
    Default = false
})

local isLooping = false -- Tracks whether the toggle is active

-- Update the toggle state
Toggle:OnChanged(function(state)
    isLooping = state
end)

-- Continuously update the level based on the toggle state
spawn(function()
    while true do
        if isLooping then
            levelPart.Text = "Join Zefyr" -- Set to custom text when toggle is ON
        else
            levelPart.Text = originalLevel -- Revert to original text when toggle is OFF
        end
        wait(0.1) -- Prevent excessive resource usage
    end
end)



local player = game.Players.LocalPlayer
local coins = player.PlayerGui:WaitForChild("hud"):WaitForChild("safezone"):WaitForChild("coins")
local lvl = player.PlayerGui:WaitForChild("hud"):WaitForChild("safezone"):WaitForChild("lvl")

local originalCoinsText = coins.Text  -- Store original text for coins
local originalLvlText = lvl.Text  -- Store original text for lvl

local Toggle = Tabs.Misc:AddToggle("Hideui", {
    Title = "Hide UI Info",
    Default = false
})

local isLooping = false -- Variable to track toggle state

-- Update the looping state when the toggle changes
Toggle:OnChanged(function(state)
    isLooping = state
end)

-- Loop to continuously check the toggle state and update UI
spawn(function()
    while true do
        if isLooping then
            coins.Text = "Zefyr"
            lvl.Text = "Zefyr"
        else
            coins.Text = originalCoinsText
            lvl.Text = originalLvlText
        end
        wait(0.1) -- Delay to prevent high resource usage
    end
end)




    

local Section = Tabs.Misc:AddSection("Information")

    Tabs.Misc:AddParagraph({
        Title = "Discord",
        Content = "Discord.gg/52QaAMTMeH"
    })

Tabs.Misc:AddParagraph({
        Title = "This script is currently in work",
        Content = "This means it doesnt have all features."
    })



local Section = Tabs.Misc:AddSection("Infinite Yield")

Tabs.Misc:AddButton({
    Title = "Load Infinite Yield",
    Description = "",
    Callback = function()
        loadstring(game:HttpGet(('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'),true))()
    end
})




local CurrentRod = nil
local isRodPrinted = false

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to update the current rod
local function updateRod()
    local model = player.Backpack or character

    for _, child in ipairs(model:GetDescendants()) do
        if child:IsA("Tool") and string.find(child.Name, "Rod") then
            if CurrentRod ~= child then
                CurrentRod = child
                if not isRodPrinted then









                        
                    print("Current rod set to:", CurrentRod.Name)
                    isRodPrinted = true
                end
            end
            return
        end
    end
end

-- Monitor tools in Backpack or Character
player.CharacterAdded:Connect(updateRod)
player.Backpack.ChildAdded:Connect(updateRod)
player.Backpack.ChildRemoved:Connect(updateRod)

-- Display the current rod
Tabs.Test:AddButton({
    Title = "Show Current Rod",
    Description = "",
    Callback = function()
     
                
        if CurrentRod then


        Fluent:Notify({
        Title = "Current Rod",
        Content = "Your Current Rod is " .. CurrentRod.Name,
        SubContent = "", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
})        
        else

        Fluent:Notify({
        Title = "Current Rod",
        Content = "You Are Not Holding A rod",
        SubContent = "This might be a bug. Requip rod.", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
})



                    
        end
    end
})















game.Lighting.brightness.Enabled = true
brightnessEffect.Brightness = 0.1




-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

    Fluent:Notify({
        Title = "Notification",
        Content = "Thank you for using our script",
        SubContent = "❤", -- Optional
        Duration = 9 -- Set to nil to make the notification not disappear
    })

Window:SelectTab(2)

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
end 
